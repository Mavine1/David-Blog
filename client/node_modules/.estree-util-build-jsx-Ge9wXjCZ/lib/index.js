/**
 * @typedef {import('estree-jsx').Node} Node
 * @typedef {import('estree-jsx').Expression} Expression
 * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression
 * @typedef {import('estree-jsx').Property} Property
 * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier
 * @typedef {import('estree-jsx').SpreadElement} SpreadElement
 * @typedef {import('estree-jsx').MemberExpression} MemberExpression
 * @typedef {import('estree-jsx').Literal} Literal
 * @typedef {import('estree-jsx').Identifier} Identifier
 * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute
 * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression
 * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName
 * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier
 *
 * @typedef {'automatic' | 'classic'} Runtime
 *   How to transform JSX.
 *
 * @typedef Options
 *   Configuration.
 *
 *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,
 *   > and `pragmaFrag` from within files through comments.
 * @property {Runtime | null | undefined} [runtime='classic']
 *   Choose the runtime.
 *
 *   Comment form: `@jsxRuntime theRuntime`.
 * @property {string | null | undefined} [importSource='react']
 *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the
 *   effective runtime is automatic.
 *
 *   Comment form: `@jsxImportSource theSource`.
 *
 *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this
 *   > provided source.
 *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),
 *   > but for ESM an export map needs to be set up to point to files:
 *   >
 *   > ```js
 *   > // â€¦
 *   > "exports": {
 *   >   // â€¦
 *   >   "./jsx-runtime": "./path/to/jsx-runtime.js",
 *   >   "./jsx-dev-runtime": "./path/to/jsx-runtime.js"
 *   >   // â€¦
 *   > ```
 * @property {string | null | undefined} [pragma='React.createElement']
 *   Identifier or member expression to call when the effective runtime is
 *   classic.
 *
 *   Comment form: `@jsx identifier`.
 * @property {string | null | undefined} [pragmaFrag='React.Fragment']
 *   Identifier or member expression to use as a symbol for fragments when the
 *   effective runtime is classic.
 *
 *   Comment form: `@jsxFrag identifier`.
 * @property {boolean | null | undefined} [development=false]
 *   When in the automatic runtime, whether to import
 *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when
 *   available.
 *
 *   This helps debugging but adds a lot of code that you donâ€™t want in
 *   production.
 * @property {string | null | undefined} [filePath]
 *   File path to the original source file.
 *
 *   Passed in location info to `jsxDEV` when using the automatic runtime with
 *   `development: true`.
 *
 * @typedef Annotations
 *   State where info from comments is gathered.
 * @property {Runtime | undefined} [jsxRuntime]
 *   Runtime.
 * @property {string | undefined} [jsx]
 *   JSX identifier (`pragma`).
 * @property {string | undefined} [jsxFrag]
 *   JSX identifier of fragment (`pragmaFrag`).
 * @property {string | undefined} [jsxImportSource]
 *   Where to import an automatic JSX runtime from.
 *
 * @typedef Imports
 *   State of used identifiers from the automatic runtime.
 * @property {boolean | undefined} [fragment]
 *   Symbol of `Fragment`.
 * @property {boolean | undefined} [jsx]
 *   Symbol of `jsx`.
 * @property {boolean | undefined} [jsxs]
 *   Symbol of `jsxs`.
 * @property {boolean | undefined} [jsxDEV]
 *   Symbol of `jsxDEV`.
 */

import {walk} from 'estree-walker'
import {name as isIdentifierName} from 'estree-util-is-identifier-name'

const regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g

/**
 * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!
 *
 * ###### Algorithm
 *
 * In almost all cases, this utility is the same as the Babel plugin, except that
 * they work on slightly di