"use strict";var e=require("jsbi");const t={};function MakeIntrinsicClass(e,t){Object.defineProperty(e.prototype,Symbol.toStringTag,{value:t,writable:!1,enumerable:!1,configurable:!0});for(const t of Object.getOwnPropertyNames(e)){const r=Object.getOwnPropertyDescriptor(e,t);r.configurable&&r.enumerable&&(r.enumerable=!1,Object.defineProperty(e,t,r))}for(const t of Object.getOwnPropertyNames(e.prototype)){const r=Object.getOwnPropertyDescriptor(e.prototype,t);r.configurable&&r.enumerable&&(r.enumerable=!1,Object.defineProperty(e.prototype,t,r))}DefineIntrinsic(t,e),DefineIntrinsic(`${t}.prototype`,e.prototype)}function DefineIntrinsic(e,r){const o=`%${e}%`;if(void 0!==t[o])throw new Error(`intrinsic ${e} already exists`);t[o]=r}function GetIntrinsic(e){return t[e]}var r,o;const n="slot-epochNanoSeconds",a="slot-timezone-identifier",i="slot-year",s="slot-month",l="slot-day",d="slot-hour",m="slot-minute",c="slot-second",h="slot-millisecond",u="slot-microsecond",T="slot-nanosecond",p="slot-calendar",f="slot-date-brand",y="slot-year-month-brand",I="slot-month-day-brand",S="slot-cached-instant",g="slot-time-zone",w="slot-years",D="slot-months",G="slot-weeks",v="slot-days",C="slot-hours",O="slot-minutes",b="slot-seconds",E="slot-milliseconds",M="slot-microseconds",R="slot-nanoseconds",F="slot-calendar-identifier",Y=new WeakMap;const P=Symbol.for("@@Temporal__GetSlots");(r=globalThis)[P]||(r[P]=function _GetSlots(e){return Y.get(e)});const Z=globalThis[P];const B=Symbol.for("@@Temporal__CreateSlots");(o=globalThis)[B]||(o[B]=function _CreateSlots(e){Y.set(e,Object.create(null))});const N=globalThis[B];function HasSlot(e,...t){if(!e||"object"!=typeof e)return!1;const r=Z(e);return!!r&&t.every((e=>e in r))}function GetSlot(e,t){const r=Z(e)?.[t];if(void 0===r)throw new TypeError(`Missing internal slot ${t}`);return r}function SetSlot(e,t,r){const o=Z(e);if(void 0===o)throw new TypeError("Missing slots for the given container");if(o[t])throw new TypeError(`${t} already has set`);o[t]=r}const j=/\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,$=new RegExp("(?:"+[`(?:${j.source})(?:\\/(?:${j.source}))*`,"Etc/GMT(?:0|[-+]\\d{1,2})","GMT[-+]?0","EST5EDT","CST6CDT","MST7MDT","PST8PDT",/(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|")+")"),k=/(?:[+\u2212-]\d{6}|\d{4})/,U=/(?:0[1-9]|1[0-2])/,A=/(?:0[1-9]|[12]\d|3[01])/,L=new RegExp(`(${k.source})(?:-(${U.source})-(${A.source})|(${U.source})(${A.source}))`),x=/(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,W=/([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,q=new RegExp(`([zZ])|${W.source}?`),H=/\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g,V=new RegExp([`^${L.source}`,`(?:(?:T|\\s+)${x.source}(?:${q.source})?)?`,`(?:\\[!?(${$.source})\\])?`,`((?:${H.source})*)$`].join(""),"i"),z=new RegExp([`^T?${x.source}`,`(?:${q.source})?`,`(?:\\[!?${$.source}\\])?`,`((?:${H.source})*)$`].join(""),"i"),_=new RegExp(`^(${k.source})-?(${U.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`),J=new RegExp(`^(?:--)?(${U.source})-?(${A.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`),K=/(\d+)(?:[.,](\d{1,9}))?/,X=new RegExp(`(?:${K.source}H)?(?:${K.source}M)?(?:${K.source}S)?`),Q=new RegExp(`^([+−-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${X.source})?$`,"i"),ee=Array.prototype.includes,te=Array.prototype.push,re=globalThis.Intl.DateTimeFormat,oe=Math.min,ne=Math.max,ae=Math.abs,ie=Math.floor,se=Math.sign,le=Math.trunc,de=Number.isNaN,me=Number.isFinite,ce=Number,he=String,ue=Number.MAX_SAFE_INTEGER,Te=Object.create,pe=Object.getOwnPropertyDescriptor,fe=Reflect.apply,ye=Reflect.ownKeys,Ie=e.BigInt(0),Se=e.BigInt(1),ge=e.BigInt(60),we=e.BigInt(24),De=e.BigInt(1e3),Ge=e.BigInt(1e6),ve=e.BigInt(1e9),Ce=e.BigInt(-1),Oe=e.multiply(e.BigInt(3600),ve),be=e.multiply(ge,ve),Ee=e.multiply(Oe,we),Me=e.multiply(e.BigInt(-86400),e.BigInt(1e17)),Re=e.multiply(e.BigInt(86400),e.BigInt(1e17)),Fe=-271821,Ye=275760,Pe=e.multiply(e.BigInt(-388152),e.BigInt(1e13)),Ze=e.multiply(Ee,e.BigInt(3660)),Be=e.multiply(Ee,e.BigInt(366)),Ne=e.multiply(Ee,e.BigInt(14)),je=["iso8601","hebrew","islamic","islamic-umalqura","islamic-tbla","islamic-civil","islamic-rgsa","islamicc","persian","ethiopic","ethioaa","coptic","chinese","dangi","roc","indian","buddhist","japanese","gregory"];function isZero(t){return e.equal(t,Ie)}function GetMethod(e,t){const r=e[t];if(void 0!==r)return r}function Call(e,t,r){const o=arguments.length>2?r:[];return fe(e,t,o)}function IsObject(e){return"object"==typeof e&&null!==e||"function"==typeof e}function ToNumber(e){if("bigint"==typeof e)throw new TypeError("Cannot convert BigInt to number");return ce(e)}function ToIntegerOrInfinity(e){const t=ToNumber(e);if(de(t)||0===t)return 0;if(!me(t))return t;const r=ie(ae(t));return 0===r?0:se(t)*r}function IsIntegralNumber(e){if("number"!=typeof e||de(e)||!me(e))return!1;const t=ae(e);return ie(t)===t}function ToString(e){if("symbol"==typeof e)throw new TypeError("Cannot convert a Symbol value to a String");return he(e)}function ToIntegerWithTruncation(e){const t=ToNumber(e);if(0===t)return 0;if(de(t)||!me(t))throw new RangeError("invalid number value");const r=le(t);return 0===r?0:r}function ToPositiveIntegerWithTruncation(e,t){const r=ToIntegerWithTruncation(e);if(r<=0){if(void 0!==t)throw new RangeError(`property '${t}' cannot be a a number less than one`);throw new RangeError("Cannot convert a number less than one to a positive integer")}return r}function ToIntegerIfIntegral(e){const t=ToNumber(e);if(!me(t))throw new RangeError("infinity is out of range");if(!IsIntegralNumber(t))throw new RangeError(`unsupported fractional value ${e}`);return 0===t?0:t}function divmod(t,r){return{quotient:e.divide(t,r),remainder:e.remainder(t,r)}}function isNegativeJSBI(t){return e.lessThan(t,Ie)}function signJSBI(e){return isZero(e)?0:isNegativeJSBI(e)?-1:1}function abs(t){return e.lessThan(t,Ie)?e.multiply(t,Ce):t}const $e=new Map([["year",ToIntegerWithTruncation],["month",ToPositiveIntegerWithTruncation],["monthCode",ToString],["day",ToPositiveIntegerWithTruncation],["hour",ToIntegerWithTruncation],["minute",ToIntegerWithTruncation],["second",ToIntegerWithTruncation],["millisecond",ToIntegerWithTruncation],["microsecond",ToIntegerWithTruncation],["nanosecond",ToIntegerWithTruncation],["years",ToIntegerIfIntegral],["months",ToIntegerIfIntegral],["weeks",ToIntegerIfIntegral],["days",ToIntegerIfIntegral],["hours",ToIntegerIfIntegral],["minutes",ToIntegerIfIntegral],["seconds",ToIntegerIfIntegral],["milliseconds",ToIntegerIfIntegral],["microseconds",ToIntegerIfIntegral],["nanoseconds",ToIntegerIfIntegral],["era",ToString],["eraYear",ToIntegerOrInfinity],["offset",ToString]]),ke=new Map([["hour",0],["minute",0],["second",0],["millisecond",0],["microsecond",0],["nanosecond",0]]),Ue=[["years","year","date"],["months","month","date"],["weeks","week","date"],["days","day","date"],["hours","hour","time"],["minutes","minute","time"],["seconds","second","time"],["milliseconds","millisecond","time"],["microseconds","microsecond","time"],["nanoseconds","nanosecond","time"]],Ae=new Map(Ue.map((e=>[e[0],e[1]]))),Le=new Map(Ue.map((([e,t])=>[t,e]))),xe=Ue.map((([,e])=>e)),We=Array.from(Ae.keys()).sort(),qe=new Map;function getIntlDateTimeFormatEnUsForTimeZone(e){let t=qe.get(e);return void 0===t&&(t=new re("en-us",{timeZone:he(e),hour12:!1,era:"short",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"}),qe.set(e,t)),t}function ToObject(e){if(null==e)throw new TypeError(`Expected object not ${e}`);return Object(e)}function CopyDataProperties(e,t,r,o){if(null==t)return;const n=ye(t);for(const a of n)if(!r.some((e=>Object.is(e,a)))&&Object.prototype.propertyIsEnumerable.call(t,a)){const r=t[a];if(o&&o.some((e=>Object.is(e,r))))continue;e[a]=r}}function IsTemporalInstant(e){return HasSlot(e,n)&&!HasSlot(e,g,p)}function IsTemporalTimeZone(e){return HasSlot(e,a)}function IsTemporalCalendar(e){return HasSlot(e,F)}function IsTemporalDuration(e){return HasSlot(e,w,D,v,C,O,b,E,M,R)}function IsTemporalDate(e){return HasSlot(e,f)}function IsTemporalTime(e){return HasSlot(e,d,m,c,h,u,T)&&!HasSlot(e,i,s,l)}function IsTemporalDateTime(e){return HasSlot(e,i,s,l,d,m,c,h,u,T)}function IsTemporalYearMonth(e){return HasSlot(e,y)}function IsTemporalMonthDay(e){return HasSlot(e,I)}function IsTemporalZonedDateTime(e){return HasSlot(e,n,g,p)}function RejectTemporalLikeObject(e){if(HasSlot(e,p)||HasSlot(e,g))throw new TypeError("with() does not support a calendar or timeZone property");if(IsTemporalTime(e))throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");if(void 0!==e.calendar)throw new TypeError("with() does not support a calendar property");if(void 0!==e.timeZone)throw new TypeError("with() does not support a timeZone property")}function ParseTemporalTimeZone(e){const{ianaName:t,offset:r,z:o}=function ParseTemporalTimeZoneString(e){if(new RegExp(`^${$.source}$`,"i").test(e))return{ianaName:e};try{const t=ParseISODateTime(e);if(t.z||t.offset||t.ianaName)return t}catch{}throw new RangeError(`Invalid time zone: ${e}`)}(e);if(t)return GetCanonicalTimeZoneIdentifier(t);if(o)return"UTC";return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r))}function MaybeFormatCalendarAnnotation(e,t){return"never"===t?"":FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e),t)}function FormatCalendarAnnotation(e,t){if("never"===t)return"";if("auto"===t&&"iso8601"===e)return"";return`[${"critical"===t?"!":""}u-ca=${e}]`}function ParseISODateTime(e){const t=V.exec(e);if(!t)throw new RangeError(`invalid ISO 8601 string: ${e}`);let r=t[1];if("−"===r[0]&&(r=`-${r.slice(1)}`),"-000000"===r)throw new RangeError(`invalid ISO 8601 string: ${e}`);const o=ToIntegerOrInfinity(r),n=ToIntegerOrInfinity(t[2]||t[4]),a=ToIntegerOrInfinity(t[3]||t[5]),i=ToIntegerOrInfinity(t[6]),s=void 0!==t[6],l=ToIntegerOrInfinity(t[7]||t[10]);let d=ToIntegerOrInfinity(t[8]||t[11]);60===d&&(d=59);const m=(t[9]||t[12])+"000000000",c=ToIntegerOrInfinity(m.slice(0,3)),h=ToIntegerOrInfinity(m.slice(3,6)),u=ToIntegerOrInfinity(m.slice(6,9));let T,p=!1;if(t[13])T=void 0,p=!0;else if(t[14]&&t[15]){const e="-"===t[14]||"−"===t[14]?"-":"+",r=t[15]||"00",o=t[16]||"00",n=t[17]||"00";let a=t[18]||"0";if(T=`${e}${r}:${o}`,+a){for(;a.endsWith("0");)a=a.slice(0,-1);T+=`:${n}.${a}`}else+n&&(T+=`:${n}`);"-00:00"===T&&(T="+00:00")}const f=t[19],y=t[20];let I;for(const[,e,t,r]of y.matchAll(H))if("u-ca"===t)void 0===I&&(I=r);else if("!"===e)throw new RangeError(`Unrecognized annotation: !${t}=${r}`);return RejectDateTime(o,n,a,i,l,d,c,h,u),{year:o,month:n,day:a,hasTime:s,hour:i,minute:l,second:d,millisecond:c,microsecond:h,nanosecond:u,ianaName:f,offset:T,z:p,calendar:I}}function ParseTemporalYearMonthString(e){const t=_.exec(e);let r,o,n,a;if(t){let a=t[1];if("−"===a[0]&&(a=`-${a.slice(1)}`),"-000000"===a)throw new RangeError(`invalid ISO 8601 string: ${e}`);r=ToIntegerOrInfinity(a),o=ToIntegerOrInfinity(t[2]);const i=t[3];for(const[,e,t,r]of i.matchAll(H))if("u-ca"===t)void 0===n&&(n=r);else if("!"===e)throw new RangeError(`Unrecognized annotation: !${t}=${r}`);if(void 0!==n&&"iso8601"!==n)throw new RangeError("YYYY-MM format is only valid with iso8601 calendar")}else{let t;if(({year:r,month:o,calendar:n,day:a,z:t}=ParseISODateTime(e)),t)throw new RangeError("Z designator not supported for PlainYearMonth")}return{year:r,month:o,calendar:n,referenceISODay:a}}function ParseTemporalMonthDayString(e){const t=J.exec(e);let r,o,n,a;if(t){r=ToIntegerOrInfinity(t[1]),o=ToIntegerOrInfinity(t[2]);const e=t[3];for(const[,t,r,o]of e.matchAll(H))if("u-ca"===r)void 0===n&&(n=o);else if("!"===t)throw new RangeError(`Unrecognized annotation: !${r}=${o}`);if(void 0!==n&&"iso8601"!==n)throw new RangeError("MM-DD format is only valid with iso8601 calendar")}else{let t;if(({month:r,day:o,calendar:n,year:a,z:t}=ParseISODateTime(e)),t)throw new RangeError("Z designator not supported for PlainMonthDay")}return{month:r,day:o,calendar:n,referenceISOYear:a}}function ParseTemporalInstant(e){let{year:t,month:r,day:o,hour:n,minute:a,second:i,millisecond:s,microsecond:l,nanosecond:d,offset:m,z:c}=function ParseTemporalInstantString(e){const t=ParseISODateTime(e);if(!t.z&&!t.offset)throw new RangeError("Temporal.Instant requires a time zone offset");return t}(e);if(!c&&!m)throw new RangeError("Temporal.Instant requires a time zone offset");const h=c?0:ParseTimeZoneOffsetString(m);({year:t,month:r,day:o,hour:n,minute:a,second:i,millisecond:s,microsecond:l,nanosecond:d}=BalanceISODateTime(t,r,o,n,a,i,s,l,d-h));const u=GetUTCEpochNanoseconds(t,r,o,n,a,i,s,l,d);if(null===u)throw new RangeError("DateTime outside of supported range");return u}function RegulateISODate(e,t,r,o){let n=e,a=t,i=r;switch(o){case"reject":RejectISODate(n,a,i);break;case"constrain":({year:n,month:a,day:i}=ConstrainISODate(n,a,i))}return{year:n,month:a,day:i}}function RegulateTime(e,t,r,o,n,a,i){let s=e,l=t,d=r,m=o,c=n,h=a;switch(i){case"reject":RejectTime(s,l,d,m,c,h);break;case"constrain":({hour:s,minute:l,second:d,millisecond:m,microsecond:c,nanosecond:h}=function ConstrainTime(e,t,r,o,n,a){const i=ConstrainToRange(e,0,23),s=ConstrainToRange(t,0,59),l=ConstrainToRange(r,0,59),d=ConstrainToRange(o,0,999),m=ConstrainToRange(n,0,999),c=ConstrainToRange(a,0,999);return{hour:i,minute:s,second:l,millisecond:d,microsecond:m,nanosecond:c}}(s,l,d,m,c,h))}return{hour:s,minute:l,second:d,millisecond:m,microsecond:c,nanosecond:h}}function ToTemporalDurationRecord(e){if(!IsObject(e))return function ParseTemporalDurationString(e){const t=Q.exec(e);if(!t)throw new RangeError(`invalid duration: ${e}`);if(t.slice(2).every((e=>void 0===e)))throw new RangeError(`invalid duration: ${e}`);const r="-"===t[1]||"−"===t[1]?-1:1,o=void 0===t[2]?0:ToIntegerWithTruncation(t[2])*r,n=void 0===t[3]?0:ToIntegerWithTruncation(t[3])*r,a=void 0===t[4]?0:ToIntegerWithTruncation(t[4])*r,i=void 0===t[5]?0:ToIntegerWithTruncation(t[5])*r,s=void 0===t[6]?0:ToIntegerWithTruncation(t[6])*r,l=t[7],d=t[8],m=t[9],c=t[10],h=t[11];let u=0,T=0,p=0;if(void 0!==l){if(d??m??c??h)throw new RangeError("only the smallest unit can be fractional");p=3600*ToIntegerOrInfinity((l+"000000000").slice(0,9))*r}else if(u=void 0===d?0:ToIntegerWithTruncation(d)*r,void 0!==m){if(c??h)throw new RangeError("only the smallest unit can be fractional");p=60*ToIntegerOrInfinity((m+"000000000").slice(0,9))*r}else T=void 0===c?0:ToIntegerWithTruncation(c)*r,void 0!==h&&(p=ToIntegerOrInfinity((h+"000000000").slice(0,9))*r);const f=p%1e3,y=le(p/1e3)%1e3,I=le(p/1e6)%1e3;return T+=le(p/1e9)%60,u+=le(p/6e10),RejectDuration(o,n,a,i,s,u,T,I,y,f),{years:o,months:n,weeks:a,days:i,hours:s,minutes:u,seconds:T,milliseconds:I,microseconds:y,nanoseconds:f}}(ToString(e));if(IsTemporalDuration(e))return{years:GetSlot(e,w),months:GetSlot(e,D),weeks:GetSlot(e,G),days:GetSlot(e,v),hours:GetSlot(e,C),minutes:GetSlot(e,O),seconds:GetSlot(e,b),milliseconds:GetSlot(e,E),microseconds:GetSlot(e,M),nanoseconds:GetSlot(e,R)};const t={years:0,months:0,weeks:0,days:0,hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0};let r=function ToTemporalPartialDurationRecord(e){if(!IsObject(e))throw new TypeError("invalid duration-like");const t={years:void 0,months:void 0,weeks:void 0,days:void 0,hours:void 0,minutes:void 0,seconds:void 0,milliseconds:void 0,microseconds:void 0,nanoseconds:void 0};let r=!1;for(const o of We){const n=e[o];void 0!==n&&(r=!0,t[o]=ToIntegerIfIntegral(n))}if(!r)throw new TypeError("invalid duration-like");return t}(e);for(const e of We){const o=r[e];void 0!==o&&(t[e]=o)}let{years:o,months:n,weeks:a,days:i,hours:s,minutes:l,seconds:d,milliseconds:m,microseconds:c,nanoseconds:h}=t;return RejectDuration(o,n,a,i,s,l,d,m,c,h),{years:o,months:n,weeks:a,days:i,hours:s,minutes:l,seconds:d,milliseconds:m,microseconds:c,nanoseconds:h}}function ToTemporalOverflow(e){return void 0===e?"constrain":GetOption(e,"overflow",["constrain","reject"],"constrain")}function ToTemporalDisambiguation(e){return void 0===e?"compatible":GetOption(e,"disambiguation",["compatible","earlier","later","reject"],"compatible")}function ToTemporalRoundingMode(e,t){return GetOption(e,"roundingMode",["ceil","floor","expand","trunc","halfCeil","halfFloor","halfExpand","halfTrunc","halfEven"],t)}function ToTemporalOffset(e,t){return void 0===e?t:GetOption(e,"offset",["prefer","use","ignore","reject"],t)}function ToCalendarNameOption(e){return GetOption(e,"calendarName",["auto","always","never","critical"],"auto")}function ToTemporalRoundingIncrement(e){let t=e.roundingIncrement;if(void 0===t)return 1;if(t=ToNumber(t),!me(t))throw new RangeError("roundingIncrement must be finite");const r=le(t);if(r<1||r>1e9)throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t}`);return r}function ValidateTemporalRoundingIncrement(e,t,r){const o=r?t:t-1;if(e>o)throw new RangeError(`roundingIncrement must be at least 1 and less than ${o}, not ${e}`);if(t%e!=0)throw new RangeError(`Rounding increment must divide evenly into ${t}`)}function ToFractionalSecondDigits(e){const t=e.fractionalSecondDigits;if(void 0===t)return"auto";if("number"!=typeof t){if("auto"!==ToString(t))throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`);return"auto"}const r=ie(t);if(!me(r)||r<0||r>9)throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`);return r}function ToSecondsStringPrecisionRecord(e,t){switch(e){case"minute":return{precision:"minute",unit:"minute",increment:1};case"second":return{precision:0,unit:"second",increment:1};case"millisecond":return{precision:3,unit:"millisecond",increment:1};case"microsecond":return{precision:6,unit:"microsecond",increment:1};case"nanosecond":return{precision:9,unit:"nanosecond",increment:1}}switch(t){case"auto":return{precision:t,unit:"nanosecond",increment:1};case 0:return{precision:t,unit:"second",increment:1};case 1:case 2:case 3:return{precision:t,unit:"millisecond",increment:10**(3-t)};case 4:case 5:case 6:return{precision:t,unit:"microsecond",increment:10**(6-t)};case 7:case 8:case 9:return{precision:t,unit:"nanosecond",increment:10**(9-t)};default:throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`)}}const He=Symbol("~required~");function GetTemporalUnit(e,t,r,o,n=[]){const a=[];for(const[,e,t]of Ue)"datetime"!==r&&r!==t||a.push(e);a.push(...n);let i=o;i===He?i=void 0:void 0!==i&&a.push(i);const s=[...a];for(const e of a){const t=Le.get(e);void 0!==t&&s.push(t)}let l=GetOption(e,t,s,i);if(void 0===l&&o===He)throw new RangeError(`${t} is required`);return Ae.has(l)?Ae.get(l):l}function ToRelativeTemporalObject(e){const t=e.relativeTo;if(void 0===t)return t;let r,o,n,a,i,s,l,d,m,c,h,u,T="option",p=!1;if(IsObject(t)){if(IsTemporalZonedDateTime(t)||IsTemporalDate(t))return t;if(IsTemporalDateTime(t))return TemporalDateTimeToDate(t);c=GetTemporalCalendarSlotValueWithISODefault(t);const e=CalendarFields(c,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]);e.push("timeZone","offset");const p=PrepareTemporalFields(t,e,[]),f=Te(null);f.overflow="constrain",({year:r,month:o,day:n,hour:a,minute:i,second:s,millisecond:l,microsecond:d,nanosecond:m}=InterpretTemporalDateTimeFields(c,p,f)),u=p.offset,void 0===u&&(T="wall"),h=p.timeZone,void 0!==h&&(h=ToTemporalTimeZoneSlotValue(h))}else{let e,f;if(({year:r,month:o,day:n,hour:a,minute:i,second:s,millisecond:l,microsecond:d,nanosecond:m,calendar:c,ianaName:e,offset:u,z:f}=ParseISODateTime(ToString(t))),e)h=ToTemporalTimeZoneSlotValue(e),f?T="exact":u||(T="wall"),p=!0;else if(f)throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");if(c||(c="iso8601"),!IsBuiltinCalendar(c))throw new RangeError(`invalid calendar identifier ${c}`);c=ASCIILowercase(c)}if(void 0===h)return CreateTemporalDate(r,o,n,c);return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r,o,n,a,i,s,l,d,m,T,"option"===T?ParseTimeZoneOffsetString(u):0,h,"compatible","reject",p),h,c)}function DefaultTemporalLargestUnit(e,t,r,o,n,a,i,s,l,d){for(const[m,c]of[["years",e],["months",t],["weeks",r],["days",o],["hours",n],["minutes",a],["seconds",i],["milliseconds",s],["microseconds",l],["nanoseconds",d]])if(0!==c)return Ae.get(m);return"nanosecond"}function LargerOfTwoTemporalUnits(e,t){return xe.indexOf(e)>xe.indexOf(t)?t:e}function PrepareTemporalFields(e,t,r,{emptySourceErrorMessage:o}={emptySourceErrorMessage:"no supported properties found"}){const n=Te(null);let a=!1;t.sort();for(const o of t){let t=e[o];if(void 0!==t)a=!0,$e.has(o)&&(t=$e.get(o)(t)),n[o]=t;else if("partial"!==r){if(ee.call(r,o))throw new TypeError(`required property '${o}' missing or undefined`);t=ke.get(o),n[o]=t}}if("partial"===r&&!a)throw new TypeError(o);return n}function ToTemporalTimeRecord(e,t="complete"){const r=["hour","microsecond","millisecond","minute","nanosecond","second"],o=PrepareTemporalFields(e,r,"partial",{emptySourceErrorMessage:"invalid time-like"}),n={};for(const e of r){const r=pe(o,e);void 0!==r?n[e]=r.value:"complete"===t&&(n[e]=0)}return n}function ToTemporalDate(e,t){let r=e;if(IsObject(r)){if(IsTemporalDate(r))return r;if(IsTemporalZonedDateTime(r)&&(ToTemporalOverflow(t),r=GetPlainDateTimeFor(GetSlot(r,g),GetSlot(r,S),GetSlot(r,p))),IsTemporalDateTime(r))return ToTemporalOverflow(t),CreateTemporalDate(GetSlot(r,i),GetSlot(r,s),GetSlot(r,l),GetSlot(r,p));const e=GetTemporalCalendarSlotValueWithISODefault(r);return CalendarDateFromFields(e,PrepareTemporalFields(r,CalendarFields(e,["day","month","monthCode","year"]),[]),t)}ToTemporalOverflow(t);let{year:o,month:n,day:a,calendar:d,z:m}=function ParseTemporalDateString(e){return ParseISODateTime(e)}(ToString(r));if(m)throw new RangeError("Z designator not supported for PlainDate");if(d||(d="iso8601"),!IsBuiltinCalendar(d))throw new RangeError(`invalid calendar identifier ${d}`);return d=ASCIILowercase(d),CreateTemporalDate(o,n,a,d)}function InterpretTemporalDateTimeFields(e,t,r){let{hour:o,minute:n,second:a,millisecond:d,microsecond:m,nanosecond:c}=ToTemporalTimeRecord(t);const h=ToTemporalOverflow(r),u=CalendarDateFromFields(e,t,r),T=GetSlot(u,i),p=GetSlot(u,s),f=GetSlot(u,l);return({hour:o,minute:n,second:a,millisecond:d,microsecond:m,nanosecond:c}=RegulateTime(o,n,a,d,m,c,h)),{year:T,month:p,day:f,hour:o,minute:n,second:a,millisecond:d,microsecond:m,nanosecond:c}}function ToTemporalDateTime(e,t){let r,o,n,a,d,m,c,h,u,T;if(IsObject(e)){if(IsTemporalDateTime(e))return e;if(IsTemporalZonedDateTime(e))return ToTemporalOverflow(t),GetPlainDateTimeFor(GetSlot(e,g),GetSlot(e,S),GetSlot(e,p));if(IsTemporalDate(e))return ToTemporalOverflow(t),CreateTemporalDateTime(GetSlot(e,i),GetSlot(e,s),GetSlot(e,l),0,0,0,0,0,0,GetSlot(e,p));T=GetTemporalCalendarSlotValueWithISODefault(e);const f=PrepareTemporalFields(e,CalendarFields(T,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]),[]);({year:r,month:o,day:n,hour:a,minute:d,second:m,millisecond:c,microsecond:h,nanosecond:u}=InterpretTemporalDateTimeFields(T,f,t))}else{let i;if(ToTemporalOverflow(t),({year:r,month:o,day:n,hour:a,minute:d,second:m,millisecond:c,microsecond:h,nanosecond:u,calendar:T,z:i}=function ParseTemporalDateTimeString(e){return ParseISODateTime(e)}(ToString(e))),i)throw new RangeError("Z designator not supported for PlainDateTime");if(RejectDateTime(r,o,n,a,d,m,c,h,u),T||(T="iso8601"),!IsBuiltinCalendar(T))throw new RangeError(`invalid calendar identifier ${T}`);T=ASCIILowercase(T)}return CreateTemporalDateTime(r,o,n,a,d,m,c,h,u,T)}function ToTemporalDuration(e){if(IsTemporalDuration(e))return e;let{years:t,months:r,weeks:o,days:n,hours:a,minutes:i,seconds:s,milliseconds:l,microseconds:d,nanoseconds:m}=ToTemporalDurationRecord(e);return new(GetIntrinsic("%Temporal.Duration%"))(t,r,o,n,a,i,s,l,d,m)}function ToTemporalInstant(e){if(IsTemporalInstant(e))return e;if(IsTemporalZonedDateTime(e)){return new(GetIntrinsic("%Temporal.Instant%"))(GetSlot(e,n))}const t=ParseTemporalInstant(ToString(e));return new(GetIntrinsic("%Temporal.Instant%"))(t)}function ToTemporalMonthDay(e,t){let r=e;if(IsObject(r)){if(IsTemporalMonthDay(r))return r;let e,o;if(HasSlot(r,p))e=GetSlot(r,p),o=!1;else{let t=r.calendar;o=void 0===t,void 0===t&&(t="iso8601"),e=ToTemporalCalendarSlotValue(t)}const n=PrepareTemporalFields(r,CalendarFields(e,["day","month","monthCode","year"]),[]);return o&&void 0!==n.month&&void 0===n.monthCode&&void 0===n.year&&(n.year=1972),CalendarMonthDayFromFields(e,n,t)}ToTemporalOverflow(t);let{month:o,day:n,referenceISOYear:a,calendar:i}=ParseTemporalMonthDayString(ToString(r));if(void 0===i&&(i="iso8601"),!IsBuiltinCalendar(i))throw new RangeError(`invalid calendar identifier ${i}`);if(i=ASCIILowercase(i),void 0===a)return RejectISODate(1972,o,n),CreateTemporalMonthDay(o,n,i);return CalendarMonthDayFromFields(i,CreateTemporalMonthDay(o,n,i,a))}function ToTemporalTime(e,t="constrain"){let r,o,n,a,i,s,l=e;if(IsObject(l)){if(IsTemporalTime(l))return l;if(IsTemporalZonedDateTime(l)&&(l=GetPlainDateTimeFor(GetSlot(l,g),GetSlot(l,S),GetSlot(l,p))),IsTemporalDateTime(l)){return new(GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l,d),GetSlot(l,m),GetSlot(l,c),GetSlot(l,h),GetSlot(l,u),GetSlot(l,T))}({hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s}=ToTemporalTimeRecord(l)),({hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s}=RegulateTime(r,o,n,a,i,s,t))}else({hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s}=function ParseTemporalTimeString(e){const t=z.exec(e);let r,o,n,a,i,s,l;if(t){r=ToIntegerOrInfinity(t[1]),o=ToIntegerOrInfinity(t[2]||t[5]),n=ToIntegerOrInfinity(t[3]||t[6]),60===n&&(n=59);const e=(t[4]||t[7])+"000000000";a=ToIntegerOrInfinity(e.slice(0,3)),i=ToIntegerOrInfinity(e.slice(3,6)),s=ToIntegerOrInfinity(e.slice(6,9)),l=t[14];for(const[,e,t,r]of l.matchAll(H))if("u-ca"!==t&&"!"===e)throw new RangeError(`Unrecognized annotation: !${t}=${r}`);if(t[8])throw new RangeError("Z designator not supported for PlainTime")}else{let t,l;if(({hasTime:l,hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s,z:t}=ParseISODateTime(e)),!l)throw new RangeError(`time is missing in string: ${e}`);if(t)throw new RangeError("Z designator not supported for PlainTime")}if(/[tT ][0-9][0-9]/.test(e))return{hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s};try{const{month:t,day:r}=ParseTemporalMonthDayString(e);RejectISODate(1972,t,r)}catch{try{const{year:t,month:r}=ParseTemporalYearMonthString(e);RejectISODate(t,r,1)}catch{return{hour:r,minute:o,second:n,millisecond:a,microsecond:i,nanosecond:s}}}throw new RangeError(`invalid ISO 8601 time-only string ${e}; may need a T prefix`)}(ToString(l))),RejectTime(r,o,n,a,i,s);return new(GetIntrinsic("%Temporal.PlainTime%"))(r,o,n,a,i,s)}function ToTemporalYearMonth(e,t){if(IsObject(e)){if(IsTemporalYearMonth(e))return e;const r=GetTemporalCalendarSlotValueWithISODefault(e);return CalendarYearMonthFromFields(r,PrepareTemporalFields(e,CalendarFields(r,["month","monthCode","year"]),[]),t)}ToTemporalOverflow(t);let{year:r,month:o,referenceISODay:n,calendar:a}=ParseTemporalYearMonthString(ToString(e));if(void 0===a&&(a="iso8601"),!IsBuiltinCalendar(a))throw new RangeError(`invalid calendar identifier ${a}`);if(a=ASCIILowercase(a),void 0===n)return RejectISODate(r,o,1),CreateTemporalYearMonth(r,o,a);return CalendarYearMonthFromFields(a,CreateTemporalYearMonth(r,o,a,n))}function InterpretISODateTimeOffset(t,r,o,i,s,l,d,m,c,h,u,T,p,f,y){const I=new(GetIntrinsic("%Temporal.PlainDateTime%"))(t,r,o,i,s,l,d,m,c);if("wall"===h||"ignore"===f){return GetSlot(GetInstantFor(T,I,p),n)}if("exact"===h||"use"===f){const n=GetUTCEpochNanoseconds(t,r,o,i,s,l,d,m,c);if(null===n)throw new RangeError("ZonedDateTime outside of supported range");return e.subtract(n,e.BigInt(u))}const S=GetPossibleInstantsFor(T,I);for(const t of S){const r=GetOffsetNanosecondsFor(T,t),o=e.toNumber(RoundNumberToIncrement(e.BigInt(r),be,"halfExpand"));if(r===u||y&&o===u)return GetSlot(t,n)}if("reject"===f){const e=FormatTimeZoneOffsetString(u),t=IsTemporalTimeZone(T)?GetSlot(T,a):"time zone";throw new RangeError(`Offset ${e} is invalid for ${I.toString()} in ${t}`)}return GetSlot(DisambiguatePossibleInstants(S,T,I,p),n)}function ToTemporalZonedDateTime(e,t){let r,o,n,a,i,s,l,d,m,c,h,u,T,p,f=!1,y="option";if(IsObject(e)){if(IsTemporalZonedDateTime(e))return e;u=GetTemporalCalendarSlotValueWithISODefault(e);const f=CalendarFields(u,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]);f.push("timeZone","offset");const I=PrepareTemporalFields(e,f,["timeZone"]);c=ToTemporalTimeZoneSlotValue(I.timeZone),h=I.offset,void 0===h&&(y="wall"),T=ToTemporalDisambiguation(t),p=ToTemporalOffset(t,"reject"),({year:r,month:o,day:n,hour:a,minute:i,second:s,millisecond:l,microsecond:d,nanosecond:m}=InterpretTemporalDateTimeFields(u,I,t))}else{let I,S;if(({year:r,month:o,day:n,hour:a,minute:i,second:s,millisecond:l,microsecond:d,nanosecond:m,ianaName:I,offset:h,z:S,calendar:u}=function ParseTemporalZonedDateTimeString(e){const t=ParseISODateTime(e);if(!t.ianaName)throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");return t}(ToString(e))),c=ToTemporalTimeZoneSlotValue(I),S?y="exact":h||(y="wall"),u||(u="iso8601"),!IsBuiltinCalendar(u))throw new RangeError(`invalid calendar identifier ${u}`);u=ASCIILowercase(u),f=!0,T=ToTemporalDisambiguation(t),p=ToTemporalOffset(t,"reject"),ToTemporalOverflow(t)}let I=0;"option"===y&&(I=ParseTimeZoneOffsetString(h));return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r,o,n,a,i,s,l,d,m,y,I,c,T,p,f),c,u)}function CreateTemporalDateSlots(e,t,r,o,n){RejectISODate(t,r,o),RejectDateRange(t,r,o),N(e),SetSlot(e,i,t),SetSlot(e,s,r),SetSlot(e,l,o),SetSlot(e,p,n),SetSlot(e,f,!0)}function CreateTemporalDate(e,t,r,o="iso8601"){const n=GetIntrinsic("%Temporal.PlainDate%"),a=Te(n.prototype);return CreateTemporalDateSlots(a,e,t,r,o),a}function CreateTemporalDateTimeSlots(e,t,r,o,n,a,f,y,I,S,g){RejectDateTime(t,r,o,n,a,f,y,I,S),RejectDateTimeRange(t,r,o,n,a,f,y,I,S),N(e),SetSlot(e,i,t),SetSlot(e,s,r),SetSlot(e,l,o),SetSlot(e,d,n),SetSlot(e,m,a),SetSlot(e,c,f),SetSlot(e,h,y),SetSlot(e,u,I),SetSlot(e,T,S),SetSlot(e,p,g)}function CreateTemporalDateTime(e,t,r,o,n,a,i,s,l,d="iso8601"){const m=GetIntrinsic("%Temporal.PlainDateTime%"),c=Te(m.prototype);return CreateTemporalDateTimeSlots(c,e,t,r,o,n,a,i,s,l,d),c}function CreateTemporalMonthDaySlots(e,t,r,o,n){RejectISODate(n,t,r),RejectDateRange(n,t,r),N(e),SetSlot(e,s,t),SetSlot(e,l,r),SetSlot(e,i,n),SetSlot(e,p,o),SetSlot(e,I,!0)}function CreateTemporalMonthDay(e,t,r="iso8601",o=1972){const n=GetIntrinsic("%Temporal.PlainMonthDay%"),a=Te(n.prototype);return CreateTemporalMonthDaySlots(a,e,t,r,o),a}function CreateTemporalYearMonthSlots(e,t,r,o,n){RejectISODate(t,r,n),function RejectYearMonthRange(e,t){RejectToRange(e,Fe,Ye),e===Fe?RejectToRange(t,4,12):e===Ye&&RejectToRange(t,1,9)}(t,r),N(e),SetSlot(e,i,t),SetSlot(e,s,r),SetSlot(e,l,n),SetSlot(e,p,o),SetSlot(e,y,!0)}function CreateTemporalYearMonth(e,t,r="iso8601",o=1){const n=GetIntrinsic("%Temporal.PlainYearMonth%"),a=Te(n.prototype);return CreateTemporalYearMonthSlots(a,e,t,r,o),a}function CreateTemporalZonedDateTimeSlots(e,t,r,o){ValidateEpochNanoseconds(t),N(e),SetSlot(e,n,t),SetSlot(e,g,r),SetSlot(e,p,o);const a=new(GetIntrinsic("%Temporal.Instant%"))(GetSlot(e,n));SetSlot(e,S,a)}function CreateTemporalZonedDateTime(e,t,r="iso8601"){const o=GetIntrinsic("%Temporal.ZonedDateTime%"),n=Te(o.prototype);return CreateTemporalZonedDateTimeSlots(n,e,t,r),n}function CalendarFields(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"),r,[t])}const r=Call(GetMethod(e,"fields"),e,[t]),o=[];for(const e of r){if("string"!=typeof e)throw new TypeError("bad return from calendar.fields()");te.call(o,e)}return o}function CalendarMergeFields(e,t,r){if("string"==typeof e){const o=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"),o,[t,r])}const o=Call(GetMethod(e,"mergeFields"),e,[t,r]);if(!IsObject(o))throw new TypeError("bad return from calendar.mergeFields()");return o}function CalendarDateAdd(e,t,r,o,n){let a=n;if("string"==typeof e){const n=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"),n,[t,r,o])}void 0===a&&(a=GetMethod(e,"dateAdd"));const i=fe(a,e,[t,r,o]);if(!IsTemporalDate(i))throw new TypeError("invalid result");return i}function CalendarDateUntil(e,t,r,o,n){let a=n;if("string"==typeof e){const n=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"),n,[t,r,o])}void 0===a&&(a=GetMethod(e,"dateUntil"));const i=fe(a,e,[t,r,o]);if(!IsTemporalDuration(i))throw new TypeError("invalid result");return i}function CalendarYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"),r,[t])}let r=Call(GetMethod(e,"year"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar year result must be an integer");if(!IsIntegralNumber(r))throw new RangeError("calendar year result must be an integer");return r}function CalendarMonth(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"),r,[t])}let r=Call(GetMethod(e,"month"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar month result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar month result must be a positive integer");return r}function CalendarMonthCode(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"),r,[t])}let r=Call(GetMethod(e,"monthCode"),e,[t]);if("string"!=typeof r)throw new TypeError("calendar monthCode result must be a string");return r}function CalendarDay(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"),r,[t])}const r=Call(GetMethod(e,"day"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar day result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar day result must be a positive integer");return r}function CalendarEra(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"),r,[t])}let r=Call(GetMethod(e,"era"),e,[t]);if(void 0===r)return r;if("string"!=typeof r)throw new TypeError("calendar era result must be a string or undefined");return r}function CalendarEraYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"),r,[t])}let r=Call(GetMethod(e,"eraYear"),e,[t]);if(void 0===r)return r;if("number"!=typeof r)throw new TypeError("calendar eraYear result must be an integer or undefined");if(!IsIntegralNumber(r))throw new RangeError("calendar eraYear result must be an integer or undefined");return r}function CalendarDayOfWeek(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"),r,[t])}const r=Call(GetMethod(e,"dayOfWeek"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar dayOfWeek result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar dayOfWeek result must be a positive integer");return r}function CalendarDayOfYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"),r,[t])}const r=Call(GetMethod(e,"dayOfYear"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar dayOfYear result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar dayOfYear result must be a positive integer");return r}function CalendarWeekOfYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"),r,[t])}const r=Call(GetMethod(e,"weekOfYear"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar weekOfYear result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar weekOfYear result must be a positive integer");return r}function CalendarYearOfWeek(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"),r,[t])}const r=Call(GetMethod(e,"yearOfWeek"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar yearOfWeek result must be an integer");if(!IsIntegralNumber(r))throw new RangeError("calendar yearOfWeek result must be an integer");return r}function CalendarDaysInWeek(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"),r,[t])}const r=Call(GetMethod(e,"daysInWeek"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar daysInWeek result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar daysInWeek result must be a positive integer");return r}function CalendarDaysInMonth(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"),r,[t])}const r=Call(GetMethod(e,"daysInMonth"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar daysInMonth result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar daysInMonth result must be a positive integer");return r}function CalendarDaysInYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"),r,[t])}const r=Call(GetMethod(e,"daysInYear"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar daysInYear result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar daysInYear result must be a positive integer");return r}function CalendarMonthsInYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"),r,[t])}const r=Call(GetMethod(e,"monthsInYear"),e,[t]);if("number"!=typeof r)throw new TypeError("calendar monthsInYear result must be a positive integer");if(!IsIntegralNumber(r)||r<1)throw new RangeError("calendar monthsInYear result must be a positive integer");return r}function CalendarInLeapYear(e,t){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"),r,[t])}const r=Call(GetMethod(e,"inLeapYear"),e,[t]);if("boolean"!=typeof r)throw new TypeError("calendar inLeapYear result must be a boolean");return r}function ToTemporalCalendarSlotValue(e){if(IsObject(e)){if(HasSlot(e,p))return GetSlot(e,p);if(!function ObjectImplementsTemporalCalendarProtocol(e){return!!IsTemporalCalendar(e)||"dateAdd"in e&&"dateFromFields"in e&&"dateUntil"in e&&"day"in e&&"dayOfWeek"in e&&"dayOfYear"in e&&"daysInMonth"in e&&"daysInWeek"in e&&"daysInYear"in e&&"fields"in e&&"id"in e&&"inLeapYear"in e&&"mergeFields"in e&&"month"in e&&"monthCode"in e&&"monthDayFromFields"in e&&"monthsInYear"in e&&"weekOfYear"in e&&"year"in e&&"yearMonthFromFields"in e&&"yearOfWeek"in e}(e))throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");return e}const t=ToString(e);if(IsBuiltinCalendar(t))return ASCIILowercase(t);let r;try{({calendar:r}=ParseISODateTime(t))}catch{try{({calendar:r}=ParseTemporalYearMonthString(t))}catch{({calendar:r}=ParseTemporalMonthDayString(t))}}if(r||(r="iso8601"),!IsBuiltinCalendar(r))throw new RangeError(`invalid calendar identifier ${r}`);return ASCIILowercase(r)}function GetTemporalCalendarSlotValueWithISODefault(e){if(HasSlot(e,p))return GetSlot(e,p);const{calendar:t}=e;return void 0===t?"iso8601":ToTemporalCalendarSlotValue(t)}function ToTemporalCalendarIdentifier(e){if("string"==typeof e)return e;const t=e.id;if("string"!=typeof t)throw new TypeError("calendar.id should be a string");return t}function ToTemporalCalendarObject(e){if(IsObject(e))return e;return new(GetIntrinsic("%Temporal.Calendar%"))(e)}function CalendarEquals(e,t){if(e===t)return!0;return ToTemporalCalendarIdentifier(e)===ToTemporalCalendarIdentifier(t)}function ThrowIfCalendarsNotEqual(e,t,r){if(e===t)return;const o=ToTemporalCalendarIdentifier(e),n=ToTemporalCalendarIdentifier(t);if(o!==n)throw new RangeError(`cannot ${r} of ${o} and ${n} calendars`)}function ConsolidateCalendars(e,t){if(e===t)return t;const r=ToTemporalCalendarIdentifier(e),o=ToTemporalCalendarIdentifier(t);if(r===o||"iso8601"===r)return t;if("iso8601"===o)return e;throw new RangeError("irreconcilable calendars")}function CalendarDateFromFields(e,t,r,o){if("string"==typeof e){const o=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"),o,[t,r])}const n=Call(o??GetMethod(e,"dateFromFields"),e,[t,r]);if(!IsTemporalDate(n))throw new TypeError("invalid result");return n}function CalendarYearMonthFromFields(e,t,r){if("string"==typeof e){const o=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"),o,[t,r])}let o=Call(GetMethod(e,"yearMonthFromFields"),e,[t,r]);if(!IsTemporalYearMonth(o))throw new TypeError("invalid result");return o}function CalendarMonthDayFromFields(e,t,r){if("string"==typeof e){const o=new(GetIntrinsic("%Temporal.Calendar%"))(e);return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"),o,[t,r])}let o=Call(GetMethod(e,"monthDayFromFields"),e,[t,r]);if(!IsTemporalMonthDay(o))throw new TypeError("invalid result");return o}function ToTemporalTimeZoneSlotValue(e){if(IsObject(e)){if(IsTemporalZonedDateTime(e))return GetSlot(e,g);if(!function ObjectImplementsTemporalTimeZoneProtocol(e){return!!IsTemporalTimeZone(e)||"getOffsetNanosecondsFor"in e&&"getPossibleInstantsFor"in e&&"id"in e}(e))throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");return e}return ParseTemporalTimeZone(ToString(e))}function ToTemporalTimeZoneIdentifier(e){if("string"==typeof e)return e;const t=e.id;if("string"!=typeof t)throw new TypeError("timeZone.id should be a string");return t}function ToTemporalTimeZoneObject(e){if(IsObject(e))return e;return new(GetIntrinsic("%Temporal.TimeZone%"))(e)}function TimeZoneEquals(e,t){if(e===t)return!0;return ToTemporalTimeZoneIdentifier(e)===ToTemporalTimeZoneIdentifier(t)}function TemporalDateTimeToDate(e){return CreateTemporalDate(GetSlot(e,i),GetSlot(e,s),GetSlot(e,l),GetSlot(e,p))}function TemporalDateTimeToTime(e){return new(GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e,d),GetSlot(e,m),GetSlot(e,c),GetSlot(e,h),GetSlot(e,u),GetSlot(e,T))}function GetOffsetNanosecondsFor(e,t,r){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.TimeZone%"))(e);return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"),r,[t])}const o=Call(r??GetMethod(e,"getOffsetNanosecondsFor"),e,[t]);if("number"!=typeof o)throw new TypeError("bad return from getOffsetNanosecondsFor");if(!IsIntegralNumber(o)||ae(o)>=864e11)throw new RangeError("out-of-range return from getOffsetNanosecondsFor");return o}function GetOffsetStringFor(e,t){return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e,t))}function GetPlainDateTimeFor(e,t,r){const o=GetSlot(t,n),a=GetOffsetNanosecondsFor(e,t);let{year:i,month:s,day:l,hour:d,minute:m,second:c,millisecond:h,microsecond:u,nanosecond:T}=GetISOPartsFromEpoch(o);return({year:i,month:s,day:l,hour:d,minute:m,second:c,millisecond:h,microsecond:u,nanosecond:T}=BalanceISODateTime(i,s,l,d,m,c,h,u,T+a)),CreateTemporalDateTime(i,s,l,d,m,c,h,u,T,r)}function GetInstantFor(e,t,r){return DisambiguatePossibleInstants(GetPossibleInstantsFor(e,t),e,t,r)}function DisambiguatePossibleInstants(t,r,o,n){const a=GetIntrinsic("%Temporal.Instant%"),f=t.length;if(1===f)return t[0];if(f)switch(n){case"compatible":case"earlier":return t[0];case"later":return t[f-1];case"reject":throw new RangeError("multiple instants found")}const y=GetSlot(o,i),I=GetSlot(o,s),S=GetSlot(o,l),g=GetSlot(o,d),w=GetSlot(o,m),D=GetSlot(o,c),G=GetSlot(o,h),v=GetSlot(o,u),C=GetSlot(o,T),O=GetUTCEpochNanoseconds(y,I,S,g,w,D,G,v,C);if(null===O)throw new RangeError("DateTime outside of supported range");const b=new a(e.subtract(O,Ee)),E=new a(e.add(O,Ee)),M=GetOffsetNanosecondsFor(r,b),R=GetOffsetNanosecondsFor(r,E)-M;switch(n){case"earlier":{const e=GetSlot(o,p),t=GetIntrinsic("%Temporal.PlainDateTime%"),n=AddDateTime(y,I,S,g,w,D,G,v,C,e,0,0,0,0,0,0,0,0,0,-R,void 0);return GetPossibleInstantsFor(r,new t(n.year,n.month,n.day,n.hour,n.minute,n.second,n.millisecond,n.microsecond,n.nanosecond,e))[0]}case"compatible":case"later":{const e=GetSlot(o,p),t=GetIntrinsic("%Temporal.PlainDateTime%"),n=AddDateTime(y,I,S,g,w,D,G,v,C,e,0,0,0,0,0,0,0,0,0,R,void 0),a=GetPossibleInstantsFor(r,new t(n.year,n.month,n.day,n.hour,n.minute,n.second,n.millisecond,n.microsecond,n.nanosecond,e));return a[a.length-1]}case"reject":throw new RangeError("no such instant found")}}function GetPossibleInstantsFor(e,t,r){if("string"==typeof e){const r=new(GetIntrinsic("%Temporal.TimeZone%"))(e);return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"),r,[t])}const o=Call(r??GetMethod(e,"getPossibleInstantsFor"),e,[t]),n=[];for(const e of o){if(!IsTemporalInstant(e))throw new TypeError("bad return from getPossibleInstantsFor");te.call(n,e)}return n}function ISOYearString(e){let t;if(e<0||e>9999){t=(e<0?"-":"+")+`000000${ae(e)}`.slice(-6)}else t=`0000${e}`.slice(-4);return t}function ISODateTimePartString(e){return`00${e}`.slice(-2)}function FormatSecondsStringPart(e,t,r,o,n){if("minute"===n)return"";const a=`:${ISODateTimePartString(e)}`;let i,s=1e6*t+1e3*r+o;if("auto"===n){if(0===s)return a;for(i=`${s}`.padStart(9,"0");"0"===i[i.length-1];)i=i.slice(0,-1)}else{if(0===n)return a;i=`${s}`.padStart(9,"0").slice(0,n)}return`${a}.${i}`}function TemporalInstantToString(e,t,r){let o=t;void 0===o&&(o="UTC");const n=GetPlainDateTimeFor(o,e,"iso8601"),a=ISOYearString(GetSlot(n,i)),p=ISODateTimePartString(GetSlot(n,s)),f=ISODateTimePartString(GetSlot(n,l)),y=ISODateTimePartString(GetSlot(n,d)),I=ISODateTimePartString(GetSlot(n,m)),S=FormatSecondsStringPart(GetSlot(n,c),GetSlot(n,h),GetSlot(n,u),GetSlot(n,T),r);let g="Z";if(void 0!==t){g=FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o,e))}return`${a}-${p}-${f}T${y}:${I}${S}${g}`}function TemporalDurationToString(t,r="auto",o){function formatNumber(t){return t<=ue?t.toString(10):e.BigInt(t).toString(10)}const n=GetSlot(t,w),a=GetSlot(t,D),i=GetSlot(t,G),s=GetSlot(t,v),l=GetSlot(t,C),d=GetSlot(t,O);let m=GetSlot(t,b),c=GetSlot(t,E),h=GetSlot(t,M),u=GetSlot(t,R);const T=DurationSign(n,a,i,s,l,d,m,c,h,u);if(o){const{unit:e,increment:t,roundingMode:r}=o;({seconds:m,milliseconds:c,microseconds:h,nanoseconds:u}=RoundDuration(0,0,0,0,0,0,m,c,h,u,t,e,r))}const p=[];n&&p.push(`${formatNumber(ae(n))}Y`),a&&p.push(`${formatNumber(ae(a))}M`),i&&p.push(`${formatNumber(ae(i))}W`),s&&p.push(`${formatNumber(ae(s))}D`);const f=[];l&&f.push(`${formatNumber(ae(l))}H`),d&&f.push(`${formatNumber(ae(d))}M`);const y=[];let I,S,g,F,Y=TotalDurationNanoseconds(0,0,0,m,c,h,u,0);({quotient:Y,remainder:I}=divmod(Y,De)),({quotient:Y,remainder:S}=divmod(Y,De)),({quotient:F,remainder:g}=divmod(Y,De));const P=1e6*ae(e.toNumber(g))+1e3*ae(e.toNumber(S))+ae(e.toNumber(I));let Z;if("auto"===r){if(0!==P)for(Z=`${P}`.padStart(9,"0");"0"===Z[Z.length-1];)Z=Z.slice(0,-1)}else 0!==r&&(Z=`${P}`.padStart(9,"0").slice(0,r));return Z&&y.unshift(".",Z),e.equal(F,Ie)&&!y.length&&"auto"===r||y.unshift(abs(F).toString()),y.length&&f.push(`${y.join("")}S`),f.length&&f.unshift("T"),p.length||f.length?`${T<0?"-":""}P${p.join("")}${f.join("")}`:"PT0S"}function TemporalDateToString(e,t="auto"){return`${ISOYearString(GetSlot(e,i))}-${ISODateTimePartString(GetSlot(e,s))}-${ISODateTimePartString(GetSlot(e,l))}${MaybeFormatCalendarAnnotation(GetSlot(e,p),t)}`}function TemporalDateTimeToString(e,t,r="auto",o){let n=GetSlot(e,i),a=GetSlot(e,s),f=GetSlot(e,l),y=GetSlot(e,d),I=GetSlot(e,m),S=GetSlot(e,c),g=GetSlot(e,h),w=GetSlot(e,u),D=GetSlot(e,T);if(o){const{unit:e,increment:t,roundingMode:r}=o;({year:n,month:a,day:f,hour:y,minute:I,second:S,millisecond:g,microsecond:w,nanosecond:D}=RoundISODateTime(n,a,f,y,I,S,g,w,D,t,e,r))}return`${ISOYearString(n)}-${ISODateTimePartString(a)}-${ISODateTimePartString(f)}T${ISODateTimePartString(y)}:${ISODateTimePartString(I)}${FormatSecondsStringPart(S,g,w,D,t)}${MaybeFormatCalendarAnnotation(GetSlot(e,p),r)}`}function TemporalMonthDayToString(e,t="auto"){let r=`${ISODateTimePartString(GetSlot(e,s))}-${ISODateTimePartString(GetSlot(e,l))}`;const o=ToTemporalCalendarIdentifier(GetSlot(e,p));if("always"===t||"critical"===t||"iso8601"!==o){r=`${ISOYearString(GetSlot(e,i))}-${r}`}const n=FormatCalendarAnnotation(o,t);return n&&(r+=n),r}function TemporalYearMonthToString(e,t="auto"){let r=`${ISOYearString(GetSlot(e,i))}-${ISODateTimePartString(GetSlot(e,s))}`;const o=ToTemporalCalendarIdentifier(GetSlot(e,p));if("always"===t||"critical"===t||"iso8601"!==o){r+=`-${ISODateTimePartString(GetSlot(e,l))}`}const n=FormatCalendarAnnotation(o,t);return n&&(r+=n),r}function TemporalZonedDateTimeToString(e,t,r="auto",o="auto",a="auto",f){let y=GetSlot(e,S);if(f){const{unit:t,increment:r,roundingMode:o}=f,a=RoundInstant(GetSlot(e,n),r,t,o);y=new(GetIntrinsic("%Temporal.Instant%"))(a)}const I=GetSlot(e,g),w=GetPlainDateTimeFor(I,y,"iso8601");let D=`${ISOYearString(GetSlot(w,i))}-${ISODateTimePartString(GetSlot(w,s))}-${ISODateTimePartString(GetSlot(w,l))}T${ISODateTimePartString(GetSlot(w,d))}:${ISODateTimePartString(GetSlot(w,m))}${FormatSecondsStringPart(GetSlot(w,c),GetSlot(w,h),GetSlot(w,u),GetSlot(w,T),t)}`;if("never"!==a){D+=FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I,y))}if("never"!==o){D+=`[${"critical"===o?"!":""}${ToTemporalTimeZoneIdentifier(I)}]`}return D+=MaybeFormatCalendarAnnotation(GetSlot(e,p),r),D}function IsTimeZoneOffsetString(e){return ze.test(he(e))}function ParseTimeZoneOffsetString(e){const t=ze.exec(he(e));if(!t)throw new RangeError(`invalid time zone offset: ${e}`);return("-"===t[1]||"−"===t[1]?-1:1)*(1e9*(60*(60*+t[2]+ +(t[3]||0))+ +(t[4]||0))+ +((t[5]||0)+"000000000").slice(0,9))}function GetCanonicalTimeZoneIdentifier(e){if(IsTimeZoneOffsetString(e)){return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e))}return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone}function GetNamedTimeZoneOffsetNanoseconds(t,r){const{year:o,month:n,day:a,hour:i,minute:s,second:l,millisecond:d,microsecond:m,nanosecond:c}=GetNamedTimeZoneDateTimeParts(t,r),h=o%400,u=(o-h)/400,T=e.multiply(e.BigInt(146097),Ee),p=GetUTCEpochNanoseconds(h,n,a,i,s,l,d,m,c),f=e.add(p,e.multiply(T,e.BigInt(u)));return e.toNumber(e.subtract(f,r))}function FormatTimeZoneOffsetString(e){const t=e<0?"-":"+",r=ae(e),o=r%1e9,n=ie(r/1e9)%60,a=ie(r/6e10)%60,i=ISODateTimePartString(ie(r/36e11)),s=ISODateTimePartString(a),l=ISODateTimePartString(n);let d="";if(o){let e=`${o}`.padStart(9,"0");for(;"0"===e[e.length-1];)e=e.slice(0,-1);d=`:${l}.${e}`}else n&&(d=`:${l}`);return`${t}${i}:${s}${d}`}function FormatISOTimeZoneOffsetString(t){let r=e.toNumber(RoundNumberToIncrement(e.BigInt(t),be,"halfExpand"));const o=r<0?"-":"+";r=ae(r);const n=r/6e10%60;return`${o}${ISODateTimePartString(ie(r/36e11))}:${ISODateTimePartString(n)}`}function GetUTCEpochNanoseconds(t,r,o,n,a,i,s,l,d){const m=new Date;m.setUTCHours(n,a,i,s),m.setUTCFullYear(t,r-1,o);const c=m.getTime();if(de(c))return null;let h=e.multiply(e.BigInt(c),Ge);return h=e.add(h,e.multiply(e.BigInt(l),De)),h=e.add(h,e.BigInt(d)),e.lessThan(h,Me)||e.greaterThan(h,Re)?null:h}function GetISOPartsFromEpoch(t){const{quotient:r,remainder:o}=divmod(t,Ge);let n=e.toNumber(r),a=e.toNumber(o);a<0&&(a+=1e6,n-=1);const i=ie(a/1e3)%1e3,s=a%1e3,l=new Date(n);return{epochMilliseconds:n,year:l.getUTCFullYear(),month:l.getUTCMonth()+1,day:l.getUTCDate(),hour:l.getUTCHours(),minute:l.getUTCMinutes(),second:l.getUTCSeconds(),millisecond:l.getUTCMilliseconds(),microsecond:i,nanosecond:s}}function GetNamedTimeZoneDateTimeParts(e,t){const{epochMilliseconds:r,millisecond:o,microsecond:n,nanosecond:a}=GetISOPartsFromEpoch(t),{year:i,month:s,day:l,hour:d,minute:m,second:c}=function GetFormatterParts(e,t){const r=getIntlDateTimeFormatEnUsForTimeZone(e).format(new Date(t));return function parseFromEnUsFormat(e){const t=e.split(/[^\w]+/);if(7!==t.length)throw new RangeError(`expected 7 parts in "${e}`);const r=+t[0],o=+t[1];let n=+t[2];const a=t[3].toUpperCase();if("B"===a||"BC"===a)n=1-n;else if("A"!==a&&"AD"!==a)throw new RangeError(`Unknown era ${a} in "${e}`);let i=+t[4];24===i&&(i=0);const s=+t[5],l=+t[6];if(!(me(n)&&me(r)&&me(o)&&me(i)&&me(s)&&me(l)))throw new RangeError(`Invalid number in "${e}`);return{year:n,month:r,day:o,hour:i,minute:s,second:l}}(r)}(e,r);return BalanceISODateTime(i,s,l,d,m,c,o,n,a)}function maxJSBI(t,r){return e.lessThan(t,r)?r:t}function afterLatestPossibleTzdbRuleChange(){return e.add(Ve(),Ze)}function GetNamedTimeZoneNextTransition(t,r){if(e.lessThan(r,Pe))return GetNamedTimeZoneNextTransition(t,Pe);const o=e.add(r,Be),n=maxJSBI(afterLatestPossibleTzdbRuleChange(),o);let a=maxJSBI(Pe,r);const i=GetNamedTimeZoneOffsetNanoseconds(t,a);let s=a,l=i;for(;i===l&&e.lessThan(e.BigInt(a),n);){if(s=e.add(a,Ne),e.greaterThan(s,Re))return null;l=GetNamedTimeZoneOffsetNanoseconds(t,s),i===l&&(a=s)}if(i===l)return null;return bisect((e=>GetNamedTimeZoneOffsetNanoseconds(t,e)),a,s,i,l)}function GetNamedTimeZonePreviousTransition(t,r){const o=afterLatestPossibleTzdbRuleChange(),a=e.greaterThan(r,o),i=a?e.subtract(r,Be):Pe;if("Africa/Casablanca"===t||"Africa/El_Aaiun"===t){const o=GetSlot(ToTemporalInstant("2088-01-01T00Z"),n);if(e.lessThan(o,r))return GetNamedTimeZonePreviousTransition(t,o)}let s=e.subtract(r,Se);if(e.lessThan(s,Pe))return null;const l=GetNamedTimeZoneOffsetNanoseconds(t,s);let d=s,m=l;for(;l===m&&e.greaterThan(s,i);){if(d=e.subtract(s,Ne),e.lessThan(d,Pe))return null;m=GetNamedTimeZoneOffsetNanoseconds(t,d),l===m&&(s=d)}if(l===m){if(a){const r=e.subtract(o,Ee);return GetNamedTimeZonePreviousTransition(t,r)}return null}return bisect((e=>GetNamedTimeZoneOffsetNanoseconds(t,e)),d,s,m,l)}function LeapYear(e){if(void 0===e)return!1;return e%4==0&&(!(e%100==0)||e%400==0)}function ISODaysInMonth(e,t){return{standard:[31,28,31,30,31,30,31,31,30,31,30,31],leapyear:[31,29,31,30,31,30,31,31,30,31,30,31]}[LeapYear(e)?"leapyear":"standard"][t-1]}function DayOfWeek(e,t,r){const o=t+(t<3?10:-2),n=e-(t<3?1:0),a=ie(n/100),i=n-100*a,s=(r+ie(2.6*o-.2)+(i+ie(i/4))+(ie(a/4)-2*a))%7;return s+(s<=0?7:0)}function DayOfYear(e,t,r){let o=r;for(let r=t-1;r>0;r--)o+=ISODaysInMonth(e,r);return o}function WeekOfYear(e,t,r){const o=DayOfYear(e,t,r),n=DayOfWeek(e,t,r)||7,a=DayOfWeek(e,1,1),i=ie((o-n+10)/7);return i<1?5===a||6===a&&LeapYear(e-1)?{week:53,year:e-1}:{week:52,year:e-1}:53===i&&(LeapYear(e)?366:365)-o<4-n?{week:1,year:e+1}:{week:i,year:e}}function DurationSign(e,t,r,o,n,a,i,s,l,d){for(const m of[e,t,r,o,n,a,i,s,l,d])if(0!==m)return m<0?-1:1;return 0}function BalanceISOYearMonth(e,t){let r=e,o=t;if(!me(r)||!me(o))throw new RangeError("infinity is out of range");return o-=1,r+=ie(o/12),o%=12,o<0&&(o+=12),o+=1,{year:r,month:o}}function BalanceISODate(e,t,r){let o=e,n=t,a=r;if(!me(a))throw new RangeError("infinity is out of range");({year:o,month:n}=BalanceISOYearMonth(o,n));const i=146097;if(ae(a)>i){const e=le(a/i);o+=400*e,a-=e*i}let s=0,l=n>2?o:o-1;for(;s=LeapYear(l)?366:365,a<-s;)o-=1,l-=1,a+=s;for(l+=1;s=LeapYear(l)?366:365,a>s;)o+=1,l+=1,a-=s;for(;a<1;)({year:o,month:n}=BalanceISOYearMonth(o,n-1)),a+=ISODaysInMonth(o,n);for(;a>ISODaysInMonth(o,n);)a-=ISODaysInMonth(o,n),({year:o,month:n}=BalanceISOYearMonth(o,n+1));return{year:o,month:n,day:a}}function BalanceISODateTime(e,t,r,o,n,a,i,s,l){const{deltaDays:d,hour:m,minute:c,second:h,millisecond:u,microsecond:T,nanosecond:p}=BalanceTime(o,n,a,i,s,l),{year:f,month:y,day:I}=BalanceISODate(e,t,r+d);return{year:f,month:y,day:I,hour:m,minute:c,second:h,millisecond:u,microsecond:T,nanosecond:p}}function BalanceTime(t,r,o,n,a,i){let s,l=e.BigInt(t),d=e.BigInt(r),m=e.BigInt(o),c=e.BigInt(n),h=e.BigInt(a),u=e.BigInt(i);return({quotient:s,remainder:u}=NonNegativeBigIntDivmod(u,De)),h=e.add(h,s),({quotient:s,remainder:h}=NonNegativeBigIntDivmod(h,De)),c=e.add(c,s),({quotient:s,remainder:c}=NonNegativeBigIntDivmod(c,De)),m=e.add(m,s),({quotient:s,remainder:m}=NonNegativeBigIntDivmod(m,ge)),d=e.add(d,s),({quotient:s,remainder:d}=NonNegativeBigIntDivmod(d,ge)),l=e.add(l,s),({quotient:s,remainder:l}=NonNegativeBigIntDivmod(l,we)),{deltaDays:e.toNumber(s),hour:e.toNumber(l),minute:e.toNumber(d),second:e.toNumber(m),millisecond:e.toNumber(c),microsecond:e.toNumber(h),nanosecond:e.toNumber(u)}}function TotalDurationNanoseconds(t,r,o,n,a,i,s,l){const d=e.BigInt(t);let m=e.BigInt(s);0!==t&&(m=e.subtract(e.BigInt(s),e.BigInt(l)));const c=e.add(e.BigInt(r),e.multiply(d,e.BigInt(24))),h=e.add(e.BigInt(o),e.multiply(c,ge)),u=e.add(e.BigInt(n),e.multiply(h,ge)),T=e.add(e.BigInt(a),e.multiply(u,De)),p=e.add(e.BigInt(i),e.multiply(T,De));return e.add(e.BigInt(m),e.multiply(p,De))}function NanosecondsToDays(t,r){const o=GetIntrinsic("%Temporal.Instant%"),a=se(e.toNumber(t));let f=e.BigInt(t),y=864e11;if(0===a)return{days:0,nanoseconds:Ie,dayLengthNs:y};if(!IsTemporalZonedDateTime(r)){let t;return({quotient:t,remainder:f}=divmod(f,e.BigInt(y))),{days:e.toNumber(t),nanoseconds:f,dayLengthNs:y}}const I=GetSlot(r,n),w=GetSlot(r,S),D=e.add(I,f),G=new o(D),v=GetSlot(r,g),C=GetSlot(r,p),O=GetPlainDateTimeFor(v,w,C),b=GetPlainDateTimeFor(v,G,C);let{days:E}=DifferenceISODateTime(GetSlot(O,i),GetSlot(O,s),GetSlot(O,l),GetSlot(O,d),GetSlot(O,m),GetSlot(O,c),GetSlot(O,h),GetSlot(O,u),GetSlot(O,T),GetSlot(b,i),GetSlot(b,s),GetSlot(b,l),GetSlot(b,d),GetSlot(b,m),GetSlot(b,c),GetSlot(b,h),GetSlot(b,u),GetSlot(b,T),C,"day",Te(null)),M=AddZonedDateTime(w,v,C,0,0,0,E,0,0,0,0,0,0),R=e.BigInt(E);if(1===a)for(;e.greaterThan(R,Ie)&&e.greaterThan(M,D);)R=e.subtract(R,Se),M=AddZonedDateTime(w,v,C,0,0,0,e.toNumber(R),0,0,0,0,0,0);f=e.subtract(D,M);let F=!1,Y=new o(M);do{const t=AddZonedDateTime(Y,v,C,0,0,0,a,0,0,0,0,0,0),r=GetSlot(Y,n);y=e.toNumber(e.subtract(t,r)),F=e.greaterThanOrEqual(e.multiply(e.subtract(f,e.BigInt(y)),e.BigInt(a)),Ie),F&&(f=e.subtract(f,e.BigInt(y)),Y=new o(t),R=e.add(R,e.BigInt(a)))}while(F);if(!isZero(R)&&signJSBI(R)!==a)throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");if(!isZero(f)&&signJSBI(f)!==a){if(isNegativeJSBI(f)&&1===a)throw new Error("assert not reached");throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign")}if(e.greaterThanOrEqual(abs(f),abs(e.BigInt(y))))throw new Error("assert not reached");return{days:e.toNumber(R),nanoseconds:f,dayLengthNs:ae(y)}}function BalanceDuration(e,t,r,o,n,a,i,s,l){let d=BalancePossiblyInfiniteDuration(e,t,r,o,n,a,i,s,l);if("positive overflow"===d||"negative overflow"===d)throw new RangeError("Duration out of range");return d}function BalancePossiblyInfiniteDuration(t,r,o,a,i,s,l,d,m){let c,h,u,T,f,y,I=t;if(IsTemporalZonedDateTime(m)){const t=AddZonedDateTime(GetSlot(m,S),GetSlot(m,g),GetSlot(m,p),0,0,0,I,r,o,a,i,s,l),d=GetSlot(m,n);c=e.subtract(t,d)}else c=TotalDurationNanoseconds(I,r,o,a,i,s,l,0);"year"===d||"month"===d||"week"===d||"day"===d?({days:I,nanoseconds:c}=NanosecondsToDays(c,m)):I=0;const w=e.lessThan(c,Ie)?-1:1;switch(c=abs(c),h=u=T=f=y=Ie,d){case"year":case"month":case"week":case"day":case"hour":({quotient:h,remainder:c}=divmod(c,De)),({quotient:u,remainder:h}=divmod(h,De)),({quotient:T,remainder:u}=divmod(u,De)),({quotient:f,remainder:T}=divmod(T,ge)),({quotient:y,remainder:f}=divmod(f,ge));break;case"minute":({quotient:h,remainder:c}=divmod(c,De)),({quotient:u,remainder:h}=divmod(h,De)),({quotient:T,remainder:u}=divmod(u,De)),({quotient:f,remainder:T}=divmod(T,ge));break;case"second":({quotient:h,remainder:c}=divmod(c,De)),({quotient:u,remainder:h}=divmod(h,De)),({quotient:T,remainder:u}=divmod(u,De));break;case"millisecond":({quotient:h,remainder:c}=divmod(c,De)),({quotient:u,remainder:h}=divmod(h,De));break;case"microsecond":({quotient:h,remainder:c}=divmod(c,De));break;case"nanosecond":break;default:throw new Error("assert not reached")}const D=e.toNumber(y)*w,G=e.toNumber(f)*w,v=e.toNumber(T)*w,C=e.toNumber(u)*w,O=e.toNumber(h)*w,b=e.toNumber(c)*w;for(const e of[I,D,G,v,C,O,b])if(!me(e))return 1===w?"positive overflow":"negative overflow";return{days:I,hours:D,minutes:G,seconds:v,milliseconds:C,microseconds:O,nanoseconds:b}}function UnbalanceDurationRelative(t,r,o,n,a,i){const s=GetIntrinsic("%Temporal.Duration%"),l=DurationSign(t,r,o,n,0,0,0,0,0,0);if(0===l)return{years:t,months:r,weeks:o,days:n};const d=e.BigInt(l);let m,c,h=e.BigInt(t),u=e.BigInt(r),T=e.BigInt(o),f=e.BigInt(n);i&&(c=ToTemporalDate(i),m=GetSlot(c,p));const y=new s(l),I=new s(0,l),S=new s(0,0,l);switch(a){case"year":break;case"month":{if(!m)throw new RangeError("a starting point is required for months balancing");let t,r;for("string"!=typeof m&&(t=GetMethod(m,"dateAdd"),r=GetMethod(m,"dateUntil"));!isZero(h);){const o=CalendarDateAdd(m,c,y,void 0,t),n=Te(null);n.largestUnit="month";const a=CalendarDateUntil(m,c,o,n,r),i=e.BigInt(GetSlot(a,D));c=o,u=e.add(u,i),h=e.subtract(h,d)}}break;case"week":{if(!m)throw new RangeError("a starting point is required for weeks balancing");const t="string"!=typeof m?GetMethod(m,"dateAdd"):void 0;for(;!isZero(h);){let r;({relativeTo:c,days:r}=MoveRelativeDate(m,c,y,t)),f=e.add(f,e.BigInt(r)),h=e.subtract(h,d)}for(;!isZero(u);){let r;({relativeTo:c,days:r}=MoveRelativeDate(m,c,I,t)),f=e.add(f,e.BigInt(r)),u=e.subtract(u,d)}break}default:{if(isZero(h)&&isZero(u)&&isZero(T))break;if(!m)throw new RangeError("a starting point is required for balancing calendar units");const t="string"!=typeof m?GetMethod(m,"dateAdd"):void 0;for(;!isZero(h);){let r;({relativeTo:c,days:r}=MoveRelativeDate(m,c,y,t)),f=e.add(f,e.BigInt(r)),h=e.subtract(h,d)}for(;!isZero(u);){let r;({relativeTo:c,days:r}=MoveRelativeDate(m,c,I,t)),f=e.add(f,e.BigInt(r)),u=e.subtract(u,d)}for(;!isZero(T);){let r;({relativeTo:c,days:r}=MoveRelativeDate(m,c,S,t)),f=e.add(f,e.BigInt(r)),T=e.subtract(T,d)}break}}return{years:e.toNumber(h),months:e.toNumber(u),weeks:e.toNumber(T),days:e.toNumber(f)}}function CalculateOffsetShift(e,t,r,o,n){if(IsTemporalZonedDateTime(e)){const a=GetSlot(e,S),i=GetSlot(e,g),s=GetSlot(e,p),l=GetOffsetNanosecondsFor(i,a),d=AddZonedDateTime(a,i,s,t,r,o,n,0,0,0,0,0,0);return GetOffsetNanosecondsFor(i,new(GetIntrinsic("%Temporal.Instant%"))(d))-l}return 0}function CreateNegatedTemporalDuration(e){return new(GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e,w),-GetSlot(e,D),-GetSlot(e,G),-GetSlot(e,v),-GetSlot(e,C),-GetSlot(e,O),-GetSlot(e,b),-GetSlot(e,E),-GetSlot(e,M),-GetSlot(e,R))}function ConstrainToRange(e,t,r){return oe(r,ne(t,e))}function ConstrainISODate(e,t,r){const o=ConstrainToRange(t,1,12);return{year:e,month:o,day:ConstrainToRange(r,1,ISODaysInMonth(e,o))}}function RejectToRange(e,t,r){if(e<t||e>r)throw new RangeError(`value out of range: ${t} <= ${e} <= ${r}`)}function RejectISODate(e,t,r){RejectToRange(t,1,12),RejectToRange(r,1,ISODaysInMonth(e,t))}function RejectDateRange(e,t,r){RejectDateTimeRange(e,t,r,12,0,0,0,0,0)}function RejectTime(e,t,r,o,n,a){RejectToRange(e,0,23),RejectToRange(t,0,59),RejectToRange(r,0,59),RejectToRange(o,0,999),RejectToRange(n,0,999),RejectToRange(a,0,999)}function RejectDateTime(e,t,r,o,n,a,i,s,l){RejectISODate(e,t,r),RejectTime(o,n,a,i,s,l)}function RejectDateTimeRange(e,t,r,o,n,a,i,s,l){if(RejectToRange(e,Fe,Ye),e===Fe&&null==GetUTCEpochNanoseconds(e,t,r+1,o,n,a,i,s,l-1)||e===Ye&&null==GetUTCEpochNanoseconds(e,t,r-1,o,n,a,i,s,l+1))throw new RangeError("DateTime outside of supported range")}function ValidateEpochNanoseconds(t){if(e.lessThan(t,Me)||e.greaterThan(t,Re))throw new RangeError("Instant outside of supported range")}function RejectDuration(e,t,r,o,n,a,i,s,l,d){const m=DurationSign(e,t,r,o,n,a,i,s,l,d);for(const c of[e,t,r,o,n,a,i,s,l,d]){if(!me(c))throw new RangeError("infinite values not allowed as duration fields");const e=se(c);if(0!==e&&e!==m)throw new RangeError("mixed-sign values not allowed as duration fields")}}function DifferenceISODate(e,t,r,o,n,a,i){switch(i){case"year":case"month":{const s=-CompareISODate(e,t,r,o,n,a);if(0===s)return{years:0,months:0,weeks:0,days:0};const l={year:e,month:t,day:r},d={year:o,month:n,day:a};let m=d.year-l.year,c=AddISODate(e,t,r,m,0,0,0,"constrain"),h=-CompareISODate(c.year,c.month,c.day,o,n,a);if(0===h)return"year"===i?{years:m,months:0,weeks:0,days:0}:{years:0,months:12*m,weeks:0,days:0};let u=d.month-l.month;if(h!==s&&(m-=s,u+=12*s),c=AddISODate(e,t,r,m,u,0,0,"constrain"),h=-CompareISODate(c.year,c.month,c.day,o,n,a),0===h)return"year"===i?{years:m,months:u,weeks:0,days:0}:{years:0,months:u+12*m,weeks:0,days:0};h!==s&&(u-=s,u===-s&&(m-=s,u=11*s),c=AddISODate(e,t,r,m,u,0,0,"constrain"));let T=0;return T=c.month===d.month?d.day-c.day:s<0?-c.day-(ISODaysInMonth(d.year,d.month)-d.day):d.day+(ISODaysInMonth(c.year,c.month)-c.day),"month"===i&&(u+=12*m,m=0),{years:m,months:u,weeks:0,days:T}}case"week":case"day":{let s,l,d;CompareISODate(e,t,r,o,n,a)<0?(l={year:e,month:t,day:r},s={year:o,month:n,day:a},d=1):(l={year:o,month:n,day:a},s={year:e,month:t,day:r},d=-1);let m=DayOfYear(s.year,s.month,s.day)-DayOfYear(l.year,l.month,l.day);for(let e=l.year;e<s.year;++e)m+=LeapYear(e)?366:365;let c=0;return"week"===i&&(c=ie(m/7),m%=7),c*=d,m*=d,{years:0,months:0,weeks:c,days:m}}default:throw new Error("assert not reached")}}function DifferenceTime(e,t,r,o,n,a,i,s,l,d,m,c){let h=i-e,u=s-t,T=l-r,p=d-o,f=m-n,y=c-a;const I=DurationSign(0,0,0,0,h,u,T,p,f,y);h*=I,u*=I,T*=I,p*=I,f*=I,y*=I;let S=0;if(({deltaDays:S,hour:h,minute:u,second:T,millisecond:p,microsecond:f,nanosecond:y}=BalanceTime(h,u,T,p,f,y)),0!=S)throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");return h*=I,u*=I,T*=I,p*=I,f*=I,y*=I,{hours:h,minutes:u,seconds:T,milliseconds:p,microseconds:f,nanoseconds:y}}function DifferenceInstant(t,r,o,n,a,i){const s=e.subtract(r,t);let l=0,d=0,m=e.toNumber(e.remainder(s,De)),c=e.toNumber(e.remainder(e.divide(s,De),De)),h=e.toNumber(e.remainder(e.divide(s,Ge),De)),u=e.toNumber(e.divide(s,ve));return({hours:l,minutes:d,seconds:u,milliseconds:h,microseconds:c,nanoseconds:m}=RoundDuration(0,0,0,0,0,0,u,h,c,m,o,n,i)),BalanceDuration(0,l,d,u,h,c,m,a)}function DifferenceISODateTime(e,t,r,o,n,a,i,s,l,d,m,c,h,u,T,p,f,y,I,S,g){let w=e,D=t,G=r,{hours:v,minutes:C,seconds:O,milliseconds:b,microseconds:E,nanoseconds:M}=DifferenceTime(o,n,a,i,s,l,h,u,T,p,f,y);const R=DurationSign(0,0,0,0,v,C,O,b,E,M);CompareISODate(d,m,c,w,D,G)===-R&&(({year:w,month:D,day:G}=BalanceISODate(w,D,G-R)),({hours:v,minutes:C,seconds:O,milliseconds:b,microseconds:E,nanoseconds:M}=BalanceDuration(-R,v,C,O,b,E,M,S)));const F=CreateTemporalDate(w,D,G,I),Y=CreateTemporalDate(d,m,c,I),P=LargerOfTwoTemporalUnits("day",S),Z=CopyOptions(g);Z.largestUnit=P;let{years:B,months:N,weeks:j,days:$}=CalendarDateUntil(I,F,Y,Z);return({days:$,hours:v,minutes:C,seconds:O,milliseconds:b,microseconds:E,nanoseconds:M}=BalanceDuration($,v,C,O,b,E,M,S)),{years:B,months:N,weeks:j,days:$,hours:v,minutes:C,seconds:O,milliseconds:b,microseconds:E,nanoseconds:M}}function DifferenceZonedDateTime(t,r,o,n,a,p){const f=e.subtract(r,t);if(e.equal(f,Ie))return{years:0,months:0,weeks:0,days:0,hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0};const y=GetIntrinsic("%Temporal.Instant%"),I=new y(t),S=new y(r),g=GetPlainDateTimeFor(o,I,n),w=GetPlainDateTimeFor(o,S,n);let{years:D,months:G,weeks:v,days:C}=DifferenceISODateTime(GetSlot(g,i),GetSlot(g,s),GetSlot(g,l),GetSlot(g,d),GetSlot(g,m),GetSlot(g,c),GetSlot(g,h),GetSlot(g,u),GetSlot(g,T),GetSlot(w,i),GetSlot(w,s),GetSlot(w,l),GetSlot(w,d),GetSlot(w,m),GetSlot(w,c),GetSlot(w,h),GetSlot(w,u),GetSlot(w,T),n,a,p);const O=AddZonedDateTime(I,o,n,D,G,v,0,0,0,0,0,0,0);let b=e.subtract(r,O);const E=CreateTemporalZonedDateTime(O,o,n);({nanoseconds:b,days:C}=NanosecondsToDays(b,E));const{hours:M,minutes:R,seconds:F,milliseconds:Y,microseconds:P,nanoseconds:Z}=BalanceDuration(0,0,0,0,0,0,e.toNumber(b),"hour");return{years:D,months:G,weeks:v,days:C,hours:M,minutes:R,seconds:F,milliseconds:Y,microseconds:P,nanoseconds:Z}}function GetDifferenceSettings(e,t,r,o,n,a){const i=Ue.reduce(((e,t)=>{const n=t[0],a=t[1],i=t[2];return"datetime"!==r&&i!==r||o.includes(a)||e.push(a,n),e}),[]);let s=GetTemporalUnit(t,"largestUnit",r,"auto");if(o.includes(s))throw new RangeError(`largestUnit must be one of ${i.join(", ")}, not ${s}`);const l=ToTemporalRoundingIncrement(t);let d=ToTemporalRoundingMode(t,"trunc");"since"===e&&(d=function NegateTemporalRoundingMode(e){switch(e){case"ceil":return"floor";case"floor":return"ceil";case"halfCeil":return"halfFloor";case"halfFloor":return"halfCeil";default:return e}}(d));const m=GetTemporalUnit(t,"smallestUnit",r,n);if(o.includes(m))throw new RangeError(`smallestUnit must be one of ${i.join(", ")}, not ${m}`);const c=LargerOfTwoTemporalUnits(a,m);if("auto"===s&&(s=c),LargerOfTwoTemporalUnits(s,m)!==s)throw new RangeError(`largestUnit ${s} cannot be smaller than smallestUnit ${m}`);const h={hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[m];return void 0!==h&&ValidateTemporalRoundingIncrement(l,h,!1),{largestUnit:s,roundingIncrement:l,roundingMode:d,smallestUnit:m}}function DifferenceTemporalInstant(e,t,r,o){const a="since"===e?-1:1,i=ToTemporalInstant(r),s=GetDifferenceSettings(e,CopyOptions(o),"time",[],"nanosecond","second"),l=GetSlot(t,n),d=GetSlot(i,n);let{hours:m,minutes:c,seconds:h,milliseconds:u,microseconds:T,nanoseconds:p}=DifferenceInstant(l,d,s.roundingIncrement,s.smallestUnit,s.largestUnit,s.roundingMode);return new(GetIntrinsic("%Temporal.Duration%"))(0,0,0,0,a*m,a*c,a*h,a*u,a*T,a*p)}function DifferenceTemporalPlainDate(e,t,r,o){const n="since"===e?-1:1,a=ToTemporalDate(r),i=GetSlot(t,p);ThrowIfCalendarsNotEqual(i,GetSlot(a,p),"compute difference between dates");const s=CopyOptions(o),l=GetDifferenceSettings(e,s,"date",[],"day","day");s.largestUnit=l.largestUnit;let{years:d,months:m,weeks:c,days:h}=CalendarDateUntil(i,t,a,s);"day"===l.smallestUnit&&1===l.roundingIncrement||({years:d,months:m,weeks:c,days:h}=RoundDuration(d,m,c,h,0,0,0,0,0,0,l.roundingIncrement,l.smallestUnit,l.roundingMode,t));return new(GetIntrinsic("%Temporal.Duration%"))(n*d,n*m,n*c,n*h,0,0,0,0,0,0)}function DifferenceTemporalPlainDateTime(e,t,r,o){const n="since"===e?-1:1,a=ToTemporalDateTime(r),f=GetSlot(t,p);ThrowIfCalendarsNotEqual(f,GetSlot(a,p),"compute difference between dates");const y=CopyOptions(o),I=GetDifferenceSettings(e,y,"datetime",[],"nanosecond","day");let{years:S,months:g,weeks:w,days:D,hours:G,minutes:v,seconds:C,milliseconds:O,microseconds:b,nanoseconds:E}=DifferenceISODateTime(GetSlot(t,i),GetSlot(t,s),GetSlot(t,l),GetSlot(t,d),GetSlot(t,m),GetSlot(t,c),GetSlot(t,h),GetSlot(t,u),GetSlot(t,T),GetSlot(a,i),GetSlot(a,s),GetSlot(a,l),GetSlot(a,d),GetSlot(a,m),GetSlot(a,c),GetSlot(a,h),GetSlot(a,u),GetSlot(a,T),f,I.largestUnit,y);const M=TemporalDateTimeToDate(t);({years:S,months:g,weeks:w,days:D,hours:G,minutes:v,seconds:C,milliseconds:O,microseconds:b,nanoseconds:E}=RoundDuration(S,g,w,D,G,v,C,O,b,E,I.roundingIncrement,I.smallestUnit,I.roundingMode,M)),({days:D,hours:G,minutes:v,seconds:C,milliseconds:O,microseconds:b,nanoseconds:E}=BalanceDuration(D,G,v,C,O,b,E,I.largestUnit));return new(GetIntrinsic("%Temporal.Duration%"))(n*S,n*g,n*w,n*D,n*G,n*v,n*C,n*O,n*b,n*E)}function DifferenceTemporalPlainTime(e,t,r,o){const n="since"===e?-1:1,a=ToTemporalTime(r),i=GetDifferenceSettings(e,CopyOptions(o),"time",[],"nanosecond","hour");let{hours:s,minutes:l,seconds:p,milliseconds:f,microseconds:y,nanoseconds:I}=DifferenceTime(GetSlot(t,d),GetSlot(t,m),GetSlot(t,c),GetSlot(t,h),GetSlot(t,u),GetSlot(t,T),GetSlot(a,d),GetSlot(a,m),GetSlot(a,c),GetSlot(a,h),GetSlot(a,u),GetSlot(a,T));({hours:s,minutes:l,seconds:p,milliseconds:f,microseconds:y,nanoseconds:I}=RoundDuration(0,0,0,0,s,l,p,f,y,I,i.roundingIncrement,i.smallestUnit,i.roundingMode)),({hours:s,minutes:l,seconds:p,milliseconds:f,microseconds:y,nanoseconds:I}=BalanceDuration(0,s,l,p,f,y,I,i.largestUnit));return new(GetIntrinsic("%Temporal.Duration%"))(0,0,0,0,n*s,n*l,n*p,n*f,n*y,n*I)}function DifferenceTemporalPlainYearMonth(e,t,r,o){const n="since"===e?-1:1,a=ToTemporalYearMonth(r),i=GetSlot(t,p);ThrowIfCalendarsNotEqual(i,GetSlot(a,p),"compute difference between months");const s=CopyOptions(o),l=GetDifferenceSettings(e,s,"date",["week","day"],"month","year");s.largestUnit=l.largestUnit;const d=CalendarFields(i,["monthCode","year"]),m=PrepareTemporalFields(t,d,[]);m.day=1;const c=CalendarDateFromFields(i,m),h=PrepareTemporalFields(a,d,[]);h.day=1;const u=CalendarDateFromFields(i,h);let{years:T,months:f}=CalendarDateUntil(i,c,u,s);"month"===l.smallestUnit&&1===l.roundingIncrement||({years:T,months:f}=RoundDuration(T,f,0,0,0,0,0,0,0,0,l.roundingIncrement,l.smallestUnit,l.roundingMode,c));return new(GetIntrinsic("%Temporal.Duration%"))(n*T,n*f,0,0,0,0,0,0,0,0)}function DifferenceTemporalZonedDateTime(e,t,r,o){const a="since"===e?-1:1,i=ToTemporalZonedDateTime(r),s=GetSlot(t,p);ThrowIfCalendarsNotEqual(s,GetSlot(i,p),"compute difference between dates");const l=CopyOptions(o),d=GetDifferenceSettings(e,l,"datetime",[],"nanosecond","hour");l.largestUnit=d.largestUnit;const m=GetSlot(t,n),c=GetSlot(i,n);let h,u,T,f,y,I,S,w,D,G;if("year"!==d.largestUnit&&"month"!==d.largestUnit&&"week"!==d.largestUnit&&"day"!==d.largestUnit)h=0,u=0,T=0,f=0,({hours:y,minutes:I,seconds:S,milliseconds:w,microseconds:D,nanoseconds:G}=DifferenceInstant(m,c,d.roundingIncrement,d.smallestUnit,d.largestUnit,d.roundingMode));else{const e=GetSlot(t,g);if(!TimeZoneEquals(e,GetSlot(i,g)))throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");({years:h,months:u,weeks:T,days:f,hours:y,minutes:I,seconds:S,milliseconds:w,microseconds:D,nanoseconds:G}=DifferenceZonedDateTime(m,c,e,s,d.largestUnit,l)),({years:h,months:u,weeks:T,days:f,hours:y,minutes:I,seconds:S,milliseconds:w,microseconds:D,nanoseconds:G}=RoundDuration(h,u,T,f,y,I,S,w,D,G,d.roundingIncrement,d.smallestUnit,d.roundingMode,t)),({years:h,months:u,weeks:T,days:f,hours:y,minutes:I,seconds:S,milliseconds:w,microseconds:D,nanoseconds:G}=AdjustRoundedDurationDays(h,u,T,f,y,I,S,w,D,G,d.roundingIncrement,d.smallestUnit,d.roundingMode,t))}return new(GetIntrinsic("%Temporal.Duration%"))(a*h,a*u,a*T,a*f,a*y,a*I,a*S,a*w,a*D,a*G)}function AddISODate(e,t,r,o,n,a,i,s){let l=e,d=t,m=r,c=a,h=i;return l+=o,d+=n,({year:l,month:d}=BalanceISOYearMonth(l,d)),({year:l,month:d,day:m}=RegulateISODate(l,d,m,s)),h+=7*c,m+=h,({year:l,month:d,day:m}=BalanceISODate(l,d,m)),{year:l,month:d,day:m}}function AddTime(e,t,r,o,n,a,i,s,l,d,m,c){let h=e,u=t,T=r,p=o,f=n,y=a;h+=i,u+=s,T+=l,p+=d,f+=m,y+=c;let I=0;return({deltaDays:I,hour:h,minute:u,second:T,millisecond:p,microsecond:f,nanosecond:y}=BalanceTime(h,u,T,p,f,y)),{deltaDays:I,hour:h,minute:u,second:T,millisecond:p,microsecond:f,nanosecond:y}}function AddDuration(t,r,o,a,i,s,l,d,m,c,h,u,T,f,y,I,w,D,G,v,C){const O=LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t,r,o,a,i,s,l,d,m,c),DefaultTemporalLargestUnit(h,u,T,f,y,I,w,D,G,v));let b,E,M,R,F,Y,P,